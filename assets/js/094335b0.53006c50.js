"use strict";(self.webpackChunksonallux_github_io=self.webpackChunksonallux_github_io||[]).push([[3103],{7172:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"frontend/testing/testing-async","title":"Testing asynchronous code","description":"Assertion is performed in asynchronous code and therefore assertion errors are not visible to jest","source":"@site/docs/frontend/testing/testing-async.md","sourceDirName":"frontend/testing","slug":"/frontend/testing/testing-async","permalink":"/docs/frontend/testing/testing-async","draft":false,"unlisted":false,"editUrl":"https://github.com/sonallux/sonallux.github.io/tree/main/docs/frontend/testing/testing-async.md","tags":[{"inline":true,"label":"frontend","permalink":"/docs/tags/frontend"},{"inline":true,"label":"testing","permalink":"/docs/tags/testing"},{"inline":true,"label":"jest","permalink":"/docs/tags/jest"},{"inline":true,"label":"rxjs","permalink":"/docs/tags/rxjs"}],"version":"current","frontMatter":{"tags":["frontend","testing","jest","rxjs"]},"sidebar":"defaultSidebar","previous":{"title":"Cypress","permalink":"/docs/frontend/testing/cypress"},"next":{"title":"Testing RxJS Code","permalink":"/docs/frontend/testing/testing-rxjs"}}');var r=s(4848),i=s(8453);const o={tags:["frontend","testing","jest","rxjs"]},a="Testing asynchronous code",c={},l=[{value:"With Angular testing utility functions",id:"with-angular-testing-utility-functions",level:2},{value:"Testing Observables",id:"testing-observables",level:2},{value:"Using <code>fakeAsync()</code> with <code>Observables</code>",id:"using-fakeasync-with-observables",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"testing-asynchronous-code",children:"Testing asynchronous code"})}),"\n",(0,r.jsx)(n.p,{children:"Assertion is performed in asynchronous code and therefore assertion errors are not visible to jest"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"it('should use window.setTimeout', () => {\n  let a = 1\n  window.setTimeout(() => {\n    a++;\n    expect(a).toBe(1) // Test passes\n  })\n});\n\nit('should use Promise', () => {\n  let a = 1\n  Promise.resolve().then(() => {\n    a++;\n    expect(a).toBe(1) // Test passes, but console has \"Unhandled Promise rejection\" error\n  })\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use done callback provided by jest"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"it('should use window.setTimeout', done => {\n  let a = 1\n  window.setTimeout(() => {\n    a++;\n    expect(a).toBe(2)\n    done()\n  })\n});\n\nit('should use Promise', done => {\n  let a = 1\n  Promise.resolve().then(() => {\n    a++;\n    expect(a).toBe(2)\n  }).then(done, done) // Call done on Promise.resolve and Promise.reject\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"Or return a Promise:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"it('should use Promise', () => {\n  let a = 1\n  return Promise.resolve().then(() => {\n    a++;\n    expect(a).toBe(2)\n  })\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"Or use async/await:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"it('should use Promise', async () => {\n  let a = 1\n  await Promise.resolve().then(() => a++)\n  expect(a).toBe(2)\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"with-angular-testing-utility-functions",children:"With Angular testing utility functions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"waitForAsync()"})," waits for all async tasks to be completed even async tasks from other tests!"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"it('should use waitForAsync', waitForAsync(() => {\n  let a = 1\n  Promise.resolve().then(() => {\n    a++;\n    expect(a).toBe(2)\n  })\n}));\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"fakeAsync()"})," does not influence other tests. It will execute all microtasks, but not macrotask. It will throw an error if there are pending macrotasks after finishing the test. Use ",(0,r.jsx)(n.code,{children:"tick()"})," to advance the specified amount of time or ",(0,r.jsx)(n.code,{children:"flush()"})," to advance till every microtask is finished. ",(0,r.jsx)(n.code,{children:"flush()"})," does not handle/wait for periodic tasks"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"class Incrementer {\n  private _a = 1\n\n  get a() {\n    return this._a;\n  }\n\n  increment() {\n    window.setTimeout(() => this._a++, 100)\n\n    // periodic task\n    //const intervalId = window.setInterval(() => {\n    //  this._a++;\n    //  //window.clearInterval(intervalId)\n    //}, 100)\n  }\n}\n\nit('should test the incrementer', fakeAsync(() => {\n  const incrementer = new Incrementer();\n  expect(incrementer.a).toBe(1)\n  incrementer.increment()\n  tick(100)\n  //flush()\n  expect(incrementer.a).toBe(2)\n}));\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing-observables",children:"Testing Observables"}),"\n",(0,r.jsx)(n.p,{children:"Pay attention whether an Observables emits synchronously or asynchronously:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"it('should test with of()', () => {\n  let a = 1\n  of(1)// of() emits is synchronous\n    .subscribe(n => a += n)\n  expect(a).toBe(2)\n});\n\nit('should test with Observable constructor', () => {\n  let a = 1\n  new Observable<number>(subscriber => subscriber.next(1))\n    .subscribe(n => a += n) // still synchronous\n  expect(a).toBe(2)\n});\n\nit('should test with Observable constructor asynchronous', () => {\n  let a = 1\n  new Observable<number>(subscriber => {\n    window.setTimeout( () => subscriber.next(1))\n  }) // asynchronous because of setTimeout\n    .subscribe(n => a += n)\n  expect(a).toBe(1)\n});\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"using-fakeasync-with-observables",children:["Using ",(0,r.jsx)(n.code,{children:"fakeAsync()"})," with ",(0,r.jsx)(n.code,{children:"Observables"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"it('should assert in subscribe', fakeAsync( () => {\n  let a = 1\n  of(1).subscribe(n => {\n    a += n\n    expect(a).toBe(1) // assertion error is caught by subscribe() and re-thrown asynchronously\n  })\n  expect(a).toBe(2)\n\n  tick() // This will make the thrown error visible\n}));\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"it('should subject', fakeAsync(async () => {\n  let a = 1;\n\n  const nPromise = firstValueFrom(of(1).pipe(delay(0))) // macrotask\n  //const nPromise = firstValueFrom(scheduled([1], asyncScheduler)) // macrotask\n  //const nPromise = firstValueFrom(scheduled([1], asapScheduler)) // microtask\n\n  tick() // needed for macrotask (asyncScheduler), but not for asapScheduler. Because microtask is awaited by await\n  //flush() // does only flush microtask\n\n  a += await nPromise\n\n  expect(a).toBe(2)\n}));\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(6540);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);