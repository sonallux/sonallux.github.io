"use strict";(self.webpackChunksonallux_github_io=self.webpackChunksonallux_github_io||[]).push([[5913],{1896:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"frontend/testing/cypress","title":"Cypress","description":"www.cypress.io","source":"@site/docs/frontend/testing/cypress.md","sourceDirName":"frontend/testing","slug":"/frontend/testing/cypress","permalink":"/docs/frontend/testing/cypress","draft":false,"unlisted":false,"editUrl":"https://github.com/sonallux/sonallux.github.io/tree/main/docs/frontend/testing/cypress.md","tags":[{"inline":true,"label":"frontend","permalink":"/docs/tags/frontend"},{"inline":true,"label":"testing","permalink":"/docs/tags/testing"}],"version":"current","frontMatter":{"tags":["frontend","testing"]},"sidebar":"defaultSidebar","previous":{"title":"Testing","permalink":"/docs/frontend/testing/"},"next":{"title":"Testing asynchronous code","permalink":"/docs/frontend/testing/testing-async"}}');var i=s(4848),o=s(8453);const r={tags:["frontend","testing"]},c="Cypress",a={},l=[{value:"<code>cy.&lt;x&gt;()</code> Functions",id:"cyx-functions",level:2},{value:"Assertions",id:"assertions",level:2},{value:"Implicit assertion",id:"implicit-assertion",level:3},{value:"Explicit assertions",id:"explicit-assertions",level:3},{value:"Custom Commands",id:"custom-commands",level:2},{value:"Component Tests",id:"component-tests",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"cypress",children:"Cypress"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.cypress.io",children:"www.cypress.io"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Selectors/Query from testing library can be used with Cypress with ",(0,i.jsx)(n.a,{href:"https://testing-library.com/docs/cypress-testing-library/intro/",children:"@testing-library/cypress"})]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"cyx-functions",children:[(0,i.jsx)(n.code,{children:"cy.<x>()"})," Functions"]}),"\n",(0,i.jsxs)(n.p,{children:["Calls to ",(0,i.jsx)(n.code,{children:"cy.<...>()"})," functions do not execute the action immediately, instead the commands are added to some kind of queue. The commands are executed all together at the end of each test. The example below show this behavior. When naively looking at the code, one would expect that the example would work, but it actually does not work."]}),"\n",(0,i.jsx)(n.p,{children:"Results are thenable, but they are not real promises. The following examples show this behavior."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"it('error', () => {\n  let foo = true;\n\n  cy.visit('')\n  cy.get('...').should('contain.text', '...').then(() => foo = false)\n\n  if (foo) {\n    throw Error('Test 123')\n  }\n})\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The automatic waiting for an element feature is applied to each function individually, but not to the whole ",(0,i.jsx)(n.code,{children:"cy."})," chain."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<header>\n  <a href="/">Home</a>\n</header>\n<nav *ngIf="!loading">\n  <a href="/page1">Page One</a>\n</nav>\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"it('Link to Page One is visible', () => {\n  cy.visit('')\n  cy.get('a').should('contain.text', 'PageOne')\n})\n"})}),"\n",(0,i.jsx)(n.h2,{id:"assertions",children:"Assertions"}),"\n",(0,i.jsxs)(n.p,{children:["Cypress does not have its own assertion library. It uses Chai. ",(0,i.jsx)(n.a,{href:"https://docs.cypress.io/guides/references/assertions",children:"Assertions - Cypress Documentation"})]}),"\n",(0,i.jsx)(n.h3,{id:"implicit-assertion",children:"Implicit assertion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"cy.get('...').should('have.text', 'Foo');\n"})}),"\n",(0,i.jsx)(n.h3,{id:"explicit-assertions",children:"Explicit assertions"}),"\n",(0,i.jsxs)(n.p,{children:["Useful for multiple assertions on the same element. The argument (here ",(0,i.jsx)(n.code,{children:"$button"}),") is not the real DOM Element, instead it is a JQuery object, because Cypress uses JQuery internally. Therefore by convention the argument is prefixed with a ",(0,i.jsx)(n.code,{children:"$"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"cy.get('...').should($button => {\n  expect($button).to.have.text('Holidays');\n  expect($button).to.have.class('mat-raised-button');\n  expect($button).to.have.attr('href', '/holidays');\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"custom-commands",children:"Custom Commands"}),"\n",(0,i.jsxs)(n.p,{children:["Custom commands (like ",(0,i.jsx)(n.code,{children:"cy.testId('...')"}),") can be defined in a ",(0,i.jsx)(n.code,{children:"e2e.ts"})," or ",(0,i.jsx)(n.code,{children:"index.ts"})," file under ",(0,i.jsx)(n.code,{children:"src/e2e/support"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"declare namespace Cypress {\n  interface Chainable<Subject> {\n    testId(selector: string): Chainable<JQuery<HTMLElement>>;\n  }\n}\n\nCypress.Commands.add('testId', (selector: string) => cy.get(`[data-testid=${selector}]`));\n"})}),"\n",(0,i.jsx)(n.h2,{id:"component-tests",children:"Component Tests"}),"\n",(0,i.jsxs)(n.p,{children:["Cypress recently added support for ",(0,i.jsx)(n.a,{href:"https://docs.cypress.io/guides/component-testing/overview",children:"component testing"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var t=s(6540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);