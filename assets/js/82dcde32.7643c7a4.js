"use strict";(self.webpackChunksonallux_github_io=self.webpackChunksonallux_github_io||[]).push([[1928],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},g=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),g=a,m=u["".concat(l,".").concat(g)]||u[g]||d[g]||r;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}g.displayName="MDXCreateElement"},9361:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=n(7462),a=(n(7294),n(3905));const r={slug:"testcontainers-during-development",title:"Using Testcontainers during development",authors:"sonallux",tags:["testcontainers","spring-boot"]},i=void 0,s={permalink:"/blog/testcontainers-during-development",editUrl:"https://github.com/sonallux/sonallux.github.io/tree/main/blog/2023-06-13-testcontainers-during-development.md",source:"@site/blog/2023-06-13-testcontainers-during-development.md",title:"Using Testcontainers during development",description:"Testcontainers is a great technology for setting up a test environment using container technology. With the latest Spring Boot 3.1 release it is also possible to use Testcontainers during development, for example when you run your application locally. In this post I will show you how to set this up.",date:"2023-06-13T00:00:00.000Z",formattedDate:"June 13, 2023",tags:[{label:"testcontainers",permalink:"/blog/tags/testcontainers"},{label:"spring-boot",permalink:"/blog/tags/spring-boot"}],readingTime:3.055,hasTruncateMarker:!0,authors:[{name:"Jonas",title:"Fullstack Software Engineer",url:"https://github.com/sonallux",imageURL:"https://github.com/sonallux.png",key:"sonallux"}],frontMatter:{slug:"testcontainers-during-development",title:"Using Testcontainers during development",authors:"sonallux",tags:["testcontainers","spring-boot"]},nextItem:{title:"Oh My Posh - A prompt theme engine for any shell",permalink:"/blog/oh-my-posh"}},l={authorsImageUrls:[void 0]},c=[{value:"Adding dependencies",id:"adding-dependencies",level:2},{value:"Configuring the containers",id:"configuring-the-containers",level:2},{value:"Running tests",id:"running-tests",level:2},{value:"Testcontainers at development time",id:"testcontainers-at-development-time",level:2}],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://testcontainers.com"},"Testcontainers")," is a great technology for setting up a test environment using container technology. With the latest Spring Boot 3.1 release it is also possible to use Testcontainers during development, for example when you run your application locally. In this post I will show you how to set this up."),(0,a.kt)("h2",{id:"adding-dependencies"},"Adding dependencies"),(0,a.kt)("p",null,"First you need to add these depenencies to your Spring Boot 3.1 application to integrate Testcontainers with Spring Boot."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},"<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-testcontainers</artifactId>\n    <scope>test</scope>\n</dependency>\n<dependency>\n    <groupId>org.testcontainers</groupId>\n    <artifactId>junit-jupiter</artifactId>\n    <scope>test</scope>\n</dependency>\n")),(0,a.kt)("p",null,"Depending on your use case you also need to install the corresponding dependency for the ",(0,a.kt)("a",{parentName:"p",href:"https://testcontainers.com/modules"},"Testcontainers modules")," you want to use. In my case I am using a PostgreSQL Database:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},"<dependency>\n    <groupId>org.testcontainers</groupId>\n    <artifactId>postgresql</artifactId>\n    <scope>test</scope>\n</dependency>\n")),(0,a.kt)("h2",{id:"configuring-the-containers"},"Configuring the containers"),(0,a.kt)("p",null,"Next we need to configure the containers that we want to start during our tests and during development. For this we create a ",(0,a.kt)("inlineCode",{parentName:"p"},"ContainersConfiguration")," class under ",(0,a.kt)("inlineCode",{parentName:"p"},"src/test/java/<your-package-name>")," and annotated it with ",(0,a.kt)("inlineCode",{parentName:"p"},"@TestConfiguration(proxyBeanMethods = false)"),". Then we can either register a bean for each container or use the ",(0,a.kt)("inlineCode",{parentName:"p"},"@ImportTestcontainers")," annotation."),(0,a.kt)("p",null,"When using the first option add normal bean definition to the ",(0,a.kt)("inlineCode",{parentName:"p"},"ContainersConfiguration")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'import org.springframework.boot.test.context.TestConfiguration;\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\nimport org.springframework.context.annotation.Bean;\nimport org.testcontainers.containers.PostgreSQLContainer;\n\n@TestConfiguration(proxyBeanMethods = false)\npublic class ContainersConfiguration {\n\n    @Bean\n    @ServiceConnection\n    public PostgreSQLContainer<?> postgreSQLContainer() {\n        return new PostgreSQLContainer<>("postgres:12.15-alpine");\n    }\n}\n')),(0,a.kt)("p",null,"For the second option you define your containers with a ",(0,a.kt)("inlineCode",{parentName:"p"},"@Container")," annotated variables inside a class or interface, like you would do it for a normal Testcontainers test using JUnit:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'import org.springframework.boot.test.context.TestConfiguration;\nimport org.springframework.boot.testcontainers.context.ImportTestcontainers;\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\nimport org.testcontainers.containers.PostgreSQLContainer;\nimport org.testcontainers.junit.jupiter.Container;\n\n@TestConfiguration(proxyBeanMethods = false)\n@ImportTestcontainers(ContainersConfiguration.Containers.class)\npublic class ContainersConfiguration {\n    public interface Containers {\n        @Container\n        @ServiceConnection\n        PostgreSQLContainer<?> postgreSQLContainer = new PostgreSQLContainer<>("postgres:12.15-alpine");\n    }\n}\n')),(0,a.kt)("p",null,"In both cases Spring Boot will detect the container definition and manage their lifecycle. The containers will be started and stopped automatically. Also note the ",(0,a.kt)("inlineCode",{parentName:"p"},"@ServiceConnection")," annotation which tells Spring Boot to automatically configure the connection to this container. In my case a ",(0,a.kt)("inlineCode",{parentName:"p"},"DataSource")," with a connection to the PostgreSQL database running in the container will be configured automatically. Have a look at ",(0,a.kt)("a",{parentName:"p",href:"https://docs.spring.io/spring-boot/docs/3.1.0/reference/html/features.html#features.testing.testcontainers.service-connections"},"the documentation")," for a list of supported service connections."),(0,a.kt)("p",null,"Which option you prefer is up to you as both lead to the same end result. I am currently using the second."),(0,a.kt)("h2",{id:"running-tests"},"Running tests"),(0,a.kt)("p",null,"With the configuration in please we can start to use the containers in tests. To enable the testcontainers intergration for a specific test class just add the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Import(ContainersConfiguration.class)")," annotation to the class and the container configuration will be picked up by spring boot. In my setup it is by design that by default Testcontaners are not started for tests, because they do have an performance impact on test execution time. I decided it is best to explicitly enable it by adding the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Import(ContainersConfiguration)")," to the test, which need a PostgreSQL Database."),(0,a.kt)("h2",{id:"testcontainers-at-development-time"},"Testcontainers at development time"),(0,a.kt)("p",null,"Finally it is time to also use the configured containers during development time. For this you must launch your application with the ",(0,a.kt)("inlineCode",{parentName:"p"},"test")," classpath, so the dependencies are available. To create a launchable version using the test classpath create an ",(0,a.kt)("inlineCode",{parentName:"p"},"DevApplication")," class in your ",(0,a.kt)("inlineCode",{parentName:"p"},"src/test/java/<package-name>")," directory. The real Application can be launched using the ",(0,a.kt)("inlineCode",{parentName:"p"},"SpringApplication.from(...)")," method and the Testcontainers configuration can be added to the ",(0,a.kt)("inlineCode",{parentName:"p"},"DevApplication")," using the ",(0,a.kt)("inlineCode",{parentName:"p"},".with()")," method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"import org.springframework.boot.SpringApplication;\n\npublic class DevApplication {\n    public static void main(String[] args) {\n        SpringApplication.from(MyApplication::main).with(ContainersConfiguration.class).run(args);\n    }\n}\n")),(0,a.kt)("p",null,"Now just execute the ",(0,a.kt)("inlineCode",{parentName:"p"},"main")," method of the ",(0,a.kt)("inlineCode",{parentName:"p"},"DevApplication")," to start you app and the containers. You can also use the Maven goal ",(0,a.kt)("inlineCode",{parentName:"p"},"spring-boot:test-run")," or Gradle task ",(0,a.kt)("inlineCode",{parentName:"p"},"bootTestRun")," to do this from the command line."),(0,a.kt)("p",null,"You can find more information about the Testcontainers integration with Spring Boot in the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.testcontainers"},"official reference documentation"),"."))}d.isMDXComponent=!0}}]);